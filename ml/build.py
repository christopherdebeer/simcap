#!/usr/bin/env python3
"""
SIMCAP ML Build Pipeline

Unified build script for training, converting, and deploying gesture models.

Usage:
    python -m ml.build --help
    python -m ml.build train --data-dir data/GAMBIT
    python -m ml.build convert --model ml/models/gesture_model.keras --version v2
    python -m ml.build all --data-dir data/GAMBIT --version v2
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path


def run_command(cmd, check=True):
    """Run a shell command and return output."""
    print(f"  $ {cmd}")
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if check and result.returncode != 0:
        print(f"  ERROR: {result.stderr}")
        sys.exit(1)
    return result


def train_model(args):
    """Train the gesture classification model."""
    print("\n" + "=" * 60)
    print("STEP 1: Training Model")
    print("=" * 60)
    
    cmd = f"python -m ml.train --data-dir {args.data_dir} --epochs {args.epochs} --output-dir {args.output_dir}"
    if args.cluster_only:
        cmd += " --cluster-only --visualize-clusters --create-templates"
    
    result = run_command(cmd)
    print(result.stdout)
    
    return Path(args.output_dir) / "gesture_model.keras"


def convert_to_tfjs(model_path, output_dir, version):
    """Convert Keras model to TensorFlow.js format."""
    print("\n" + "=" * 60)
    print("STEP 2: Converting to TensorFlow.js")
    print("=" * 60)
    
    tfjs_dir = Path(output_dir) / f"gesture_{version}"
    tfjs_dir.mkdir(parents=True, exist_ok=True)
    
    # Use Python API for conversion (more reliable than CLI)
    script = f'''
import tensorflow as tf
import tensorflowjs as tfjs
model = tf.keras.models.load_model("{model_path}")
tfjs.converters.save_keras_model(model, "{tfjs_dir}")
print("Converted successfully")
'''
    
    result = run_command(f'python3 -c \'{script}\'')
    print(result.stdout)
    
    # Fix Keras 3 to TensorFlow.js compatibility issue
    # Keras 3 exports "batch_shape" but TensorFlow.js expects "batchInputShape"
    fix_tfjs_keras3_compat(tfjs_dir)
    
    return tfjs_dir


def fix_tfjs_keras3_compat(tfjs_dir):
    """Fix Keras 3 to TensorFlow.js compatibility issues in model.json.
    
    Keras 3 exports InputLayer with 'batch_shape' (snake_case) but
    TensorFlow.js expects 'batchInputShape' (camelCase).
    """
    model_json_path = Path(tfjs_dir) / "model.json"
    if not model_json_path.exists():
        return
    
    with open(model_json_path, 'r') as f:
        content = f.read()
    
    # Fix the batch_shape -> batchInputShape issue
    if '"batch_shape"' in content:
        content = content.replace('"batch_shape"', '"batchInputShape"')
        with open(model_json_path, 'w') as f:
            f.write(content)
        print("  Fixed Keras 3 compatibility: batch_shape -> batchInputShape")


def convert_to_tflite(model_path, output_dir, quantize=True):
    """Convert Keras model to TFLite format for embedded/TinyML."""
    print("\n" + "=" * 60)
    print("STEP 3: Converting to TFLite (TinyML)")
    print("=" * 60)
    
    tflite_path = Path(output_dir) / "gesture_model.tflite"
    tflite_quant_path = Path(output_dir) / "gesture_model_quant.tflite"
    
    script = f'''
import tensorflow as tf
import numpy as np

# Load model
model = tf.keras.models.load_model("{model_path}")

# Standard TFLite conversion
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()
with open("{tflite_path}", "wb") as f:
    f.write(tflite_model)
print(f"Standard TFLite: {len(tflite_model)} bytes")

# Quantized TFLite (int8) for TinyML
converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.target_spec.supported_types = [tf.float16]  # float16 quantization
tflite_quant = converter.convert()
with open("{tflite_quant_path}", "wb") as f:
    f.write(tflite_quant)
print(f"Quantized TFLite (float16): {len(tflite_quant)} bytes")
'''
    
    result = run_command(f'python3 -c \'{script}\'')
    print(result.stdout)
    
    return tflite_path, tflite_quant_path


def generate_c_header(tflite_path, output_dir):
    """Generate C header file for embedding TFLite model in firmware."""
    print("\n" + "=" * 60)
    print("STEP 4: Generating C Header for Embedded")
    print("=" * 60)
    
    header_path = Path(output_dir) / "gesture_model.h"
    
    with open(tflite_path, 'rb') as f:
        model_data = f.read()
    
    # Generate C array
    hex_array = ', '.join(f'0x{b:02x}' for b in model_data)
    
    header_content = f'''/**
 * SIMCAP Gesture Model - TFLite Embedded
 * 
 * Auto-generated by ml/build.py
 * Generated: {datetime.now().isoformat()}
 * Model size: {len(model_data)} bytes
 * 
 * Usage (ESP32/Arduino):
 *   #include "gesture_model.h"
 *   const tflite::Model* model = tflite::GetModel(gesture_model_tflite);
 */

#ifndef GESTURE_MODEL_H
#define GESTURE_MODEL_H

#include <stdint.h>

// Model configuration
#define GESTURE_MODEL_WINDOW_SIZE 50
#define GESTURE_MODEL_NUM_FEATURES 9
#define GESTURE_MODEL_NUM_CLASSES 10

// Gesture labels
static const char* GESTURE_LABELS[] = {{
    "rest", "fist", "open_palm", "index_up", "peace",
    "thumbs_up", "ok_sign", "pinch", "grab", "wave"
}};

// Normalization statistics (from training)
static const float GESTURE_MEAN[] = {{
    -1106.31f, -3629.05f, -2285.71f, 2740.34f, -14231.48f,
    -19574.75f, 509.62f, 909.94f, -558.86f
}};

static const float GESTURE_STD[] = {{
    3468.31f, 5655.28f, 4552.77f, 1781.28f, 3627.35f,
    1845.62f, 380.11f, 318.77f, 409.51f
}};

// TFLite model data
alignas(8) const unsigned char gesture_model_tflite[] = {{
{hex_array}
}};

const unsigned int gesture_model_tflite_len = {len(model_data)};

#endif // GESTURE_MODEL_H
'''
    
    with open(header_path, 'w') as f:
        f.write(header_content)
    
    print(f"  Generated: {header_path}")
    print(f"  Model size: {len(model_data)} bytes")
    
    return header_path


def update_web_model_registry(version, tfjs_dir, stats):
    """Update the web model registry with new version."""
    print("\n" + "=" * 60)
    print("STEP 5: Updating Web Model Registry")
    print("=" * 60)
    
    # Copy to web directory
    web_models_dir = Path("src/web/GAMBIT/models") / f"gesture_{version}"
    if web_models_dir.exists():
        shutil.rmtree(web_models_dir)
    shutil.copytree(tfjs_dir, web_models_dir)
    
    print(f"  Copied model to: {web_models_dir}")
    
    # Update gesture-inference.js registry
    inference_js = Path("src/web/GAMBIT/gesture-inference.js")
    if inference_js.exists():
        content = inference_js.read_text()
        
        # Check if version already exists
        if f"'{version}':" not in content:
            # Add new version to registry
            new_entry = f'''    '{version}': {{
        path: 'models/gesture_{version}/model.json',
        labels: ['rest', 'fist', 'open_palm', 'index_up', 'peace', 'thumbs_up', 'ok_sign', 'pinch', 'grab', 'wave'],
        stats: {{
            mean: {stats['mean']},
            std: {stats['std']}
        }},
        description: 'Model trained on {datetime.now().strftime("%Y-%m-%d")}',
        date: '{datetime.now().strftime("%Y-%m-%d")}'
    }},'''
            
            # Insert before closing brace of GESTURE_MODELS
            content = content.replace(
                "const GESTURE_MODELS = {",
                f"const GESTURE_MODELS = {{\n{new_entry}"
            )
            inference_js.write_text(content)
            print(f"  Added {version} to model registry")
    
    return web_models_dir


def generate_build_manifest(args, outputs):
    """Generate build manifest with all outputs."""
    manifest = {
        "build_time": datetime.now().isoformat(),
        "version": args.version,
        "config": {
            "data_dir": args.data_dir,
            "epochs": args.epochs,
            "window_size": 50,
            "stride": 25
        },
        "outputs": {k: str(v) for k, v in outputs.items()},
        "model_info": {
            "input_shape": [None, 50, 9],
            "output_shape": [None, 10],
            "labels": ["rest", "fist", "open_palm", "index_up", "peace",
                      "thumbs_up", "ok_sign", "pinch", "grab", "wave"]
        }
    }
    
    manifest_path = Path(args.output_dir) / "build_manifest.json"
    with open(manifest_path, 'w') as f:
        json.dump(manifest, f, indent=2)
    
    print(f"\n  Build manifest: {manifest_path}")
    return manifest_path


def main():
    parser = argparse.ArgumentParser(description='SIMCAP ML Build Pipeline')
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Train command
    train_parser = subparsers.add_parser('train', help='Train gesture model')
    train_parser.add_argument('--data-dir', default='data/GAMBIT')
    train_parser.add_argument('--output-dir', default='ml/models')
    train_parser.add_argument('--epochs', type=int, default=50)
    train_parser.add_argument('--cluster-only', action='store_true')
    
    # Convert command
    convert_parser = subparsers.add_parser('convert', help='Convert model to deployment formats')
    convert_parser.add_argument('--model', required=True, help='Path to Keras model')
    convert_parser.add_argument('--output-dir', default='ml/models')
    convert_parser.add_argument('--version', default='v1')
    
    # All command (train + convert)
    all_parser = subparsers.add_parser('all', help='Full pipeline: train + convert')
    all_parser.add_argument('--data-dir', default='data/GAMBIT')
    all_parser.add_argument('--output-dir', default='ml/models')
    all_parser.add_argument('--epochs', type=int, default=50)
    all_parser.add_argument('--version', default='v1')
    all_parser.add_argument('--cluster-only', action='store_true')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    outputs = {}
    
    if args.command == 'train':
        outputs['keras'] = train_model(args)
        
    elif args.command == 'convert':
        model_path = Path(args.model)
        outputs['tfjs'] = convert_to_tfjs(model_path, args.output_dir, args.version)
        outputs['tflite'], outputs['tflite_quant'] = convert_to_tflite(model_path, args.output_dir)
        outputs['c_header'] = generate_c_header(outputs['tflite_quant'], args.output_dir)
        
        # Load stats from training results
        results_path = Path(args.output_dir) / "training_results.json"
        if results_path.exists():
            with open(results_path) as f:
                results = json.load(f)
            stats = results.get('summary', {}).get('stats', {})
        else:
            stats = {'mean': [], 'std': []}
        
        outputs['web_model'] = update_web_model_registry(args.version, outputs['tfjs'], stats)
        
    elif args.command == 'all':
        # Train
        outputs['keras'] = train_model(args)
        
        # Convert
        outputs['tfjs'] = convert_to_tfjs(outputs['keras'], args.output_dir, args.version)
        outputs['tflite'], outputs['tflite_quant'] = convert_to_tflite(outputs['keras'], args.output_dir)
        outputs['c_header'] = generate_c_header(outputs['tflite_quant'], args.output_dir)
        
        # Load stats
        results_path = Path(args.output_dir) / "training_results.json"
        if results_path.exists():
            with open(results_path) as f:
                results = json.load(f)
            stats = results.get('summary', {}).get('stats', {})
        else:
            stats = {'mean': [], 'std': []}
        
        outputs['web_model'] = update_web_model_registry(args.version, outputs['tfjs'], stats)
        outputs['manifest'] = generate_build_manifest(args, outputs)
    
    print("\n" + "=" * 60)
    print("BUILD COMPLETE")
    print("=" * 60)
    for name, path in outputs.items():
        print(f"  {name}: {path}")


if __name__ == '__main__':
    main()
